<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
	xmlns="http://www.w3.org/1999/xhtml"
	xmlns:xf="http://www.w3.org/2002/xforms"
	xmlns:fp="urn:formsplayer.com"
>
	<head>
		<title>Serialise XML</title>

		<xf:model
			id="mdlMessage"
			functions="fp:HTMLserialise"
		>
			<xf:instance>
				<message>
					<greeting>Hello</greeting>
					<who>World</who>
				</message>
			</xf:instance>
		</xf:model>
		
		<style type="text/css">
			body {
				font-family			:	"Trebuchet MS", Verdana, Helvetica, sans-serif;
			}
			
			xf\:select1,
			xf\:input,
			xf\:output
			{
				display			:	block;
				margin-bottom	:	5px;
			}
			
			xf\:label {
				width	:	200px;
			}
			
			.normalText {
				font-weight		:	normal;
			}
			
			.boldText {
				font-weight		:	bold;
			}
			
			.debug {
				background-color	:	#000000;
				color				:	#ffffff;
				
			}
		</style>
	</head>

	<body>
		<h1>
			Serialise XML
		</h1>
		<p>
			In this sample we will use an external function library to render the contents
			of instance data as a string of XML text. This is useful when debugging new forms.
		</p>
		<p>
			The first step is to make our form aware of the external function. We'll use
			the Hello World! sample as our
			starting point, and we need to add the formsPlayer namespace to it: 
			<code>
				<pre>

	&lt;?xml version="1.0" encoding="iso-8859-1"?>
	&lt;html
		xmlns="http://www.w3.org/1999/xhtml"
		xmlns:xf="http://www.w3.org/2002/xforms"
	 	<span class="boldText">xmlns:fp="urn:formsplayer.com"</span>
	>

				</pre>
			</code>
		</p>
		<p>
			Next we need to make the model aware of the name of the function within
			the library that we will be using. This is done by adding the names of each
			function that you want to call - along with its namespace prefix - to the
			model. The namespace prefix will now act as a proxy for the library name.
			The	names of any functions you want to call must be listed in the xf:functions
			attribute (more	information about the xf:functions attribute is
			<a href="http://www.w3.org/TR/2002/CR-xforms-20021112/slice3.html#structure-model">available here</a>):
			<code>
				<pre>

	&lt;xf:model
		id="mdlMessage"
		<span class="boldText">functions="fp:HTMLserialise"</span>
	>
		&lt;xf:instance>
			...

				</pre>
			</code>
		</p>
		<p>
			Note that by defining external functions in this way, XForms remains platform
			independent. However, in every XForms processor there will be a platform
			specific way of binding a function library to a namespace. In formsPlayer this
			is in the formsPlayer.xml configuration file, which is in the directory where
			you installed formsPlayer. The default installation has one entry, which binds
			the namespace 'urn:formsplayer.com' to a COM object, invoked with the PROGID
			'XPathFunctions.FuncLib' (please note that this PROGID may change in the final
			version of formsPlayer):
			<code>
				<pre>

	&lt;config>
		&lt;library URI="urn:formsplayer.com">XPathFunctions.FuncLib&lt;/library>
	&lt;/config>

				</pre>
			</code>
		</p>
		<p>
			You can of course add your own function libraries using this technique.
		</p>
		<p>
			Now that we have indicated to our model that this function is available
			we can use it just as we would use any other functions in XPath statements.
			In this case we will use the fp:HTMLserialise function to show the contents
			of the instance data, as it changes:
			<code>
				<pre>

	&lt;xf:output value="<span class="attention">fp:HTMLserialise(/)</span>" class="debug">
		&lt;xf:label>Contents of instance data in 'mdlMessage'&lt;/xf:label>
	&lt;/xf:output>

				</pre>
			</code>
		</p>
		<p>
			As you can see, the function takes one parameter, which	is a nodelist. This
			nodelist can be obtained with any XPath functions you want to use. Once the
			nodelist is obtained, the function simply renders the nodes rerefenced,
			with indentation to make them easier to see. Note that as you change the data
			in the following form, the serialisation changes, since it is
			part of the dependency tree for the form, just like any other form control:
		</p>
		<xf:output value="fp:HTMLserialise(/)" class="debug">
			<xf:label>Contents of instance data in 'mdlMessage'</xf:label>
		</xf:output>

		<xf:select1 ref="greeting">
			<xf:label>Change Greeting</xf:label>
			<xf:hint>Choose the greeting that you would like to use</xf:hint>
			<xf:item>
				<xf:label>Hello</xf:label>
				<xf:value>Hello</xf:value>
			</xf:item>
			<xf:item>
				<xf:label>Goodbye</xf:label>
				<xf:value>Goodbye</xf:value>
			</xf:item>
		</xf:select1>

		<xf:input ref="who">
			<xf:label>Greet Who?</xf:label>
			<xf:hint>Please say who you would like to greet</xf:hint>
		</xf:input>

		<xf:output value="concat(greeting, '&#160;', who, '!')" class="boldText">
			<xf:label class="normalText">Your greeting is:</xf:label>
		</xf:output>
	</body>
</html>
